import * from "std/env"
import * from "std/math"
import * from "../utils.ab"

fun get_page_options(options: [Text], page: Int, page_size: Int): [Text] {
    let start = page * page_size
    let end = start + page_size
    if end > len(options) {
        end = len(options)
    }
    let result = [Text]
    for i in start..end {
        result += [options[i]]
    }
    return result
}

fun get_page_start(page: Int, page_size: Int): Int {
    return page * page_size
}

fun render_choose_page(page_options: [Text], sel: Int, cursor: Text, display_count: Int, term_width: Int): Null {
    let cursor_len = len(cursor)
    let max_option_width = term_width - cursor_len - 1
    for i in 0..len(page_options) {
        let truncated_option = cutoff_text(page_options[i], max_option_width)
        if i == sel {
            eprintf(colored_secondary(cursor + truncated_option + "\n"))
        } else {
            print_blank(cursor_len)
            eprintf(truncated_option + "\n")
        }
    }
    let remaining_slots = display_count - len(page_options)
    if remaining_slots > 0 { // Amber bug gaurd
        for _ in 0..remaining_slots {
            eprintf("\x1b[K\n")
        }
    }
}

fun render_multi_choose_page(page_options: [Text], checked: [Bool], page_start: Int, sel: Int, cursor: Text, display_count: Int, term_width: Int): Null {
    let cursor_len = len(cursor)
    let check_mark_len = 2 // "✓ " or "• "
    let max_option_width = term_width - cursor_len - check_mark_len - 1
    for i in 0..len(page_options) {
        let global_idx = page_start + i
        let check_mark = checked[global_idx] then "✓ " else "• "
        let truncated_option = cutoff_text(page_options[i], max_option_width)
        if {
            i == sel: eprintf(colored_secondary(cursor + check_mark + truncated_option + "\n"))
            checked[global_idx]: {
                print_blank(cursor_len)
                eprintf(colored_secondary(check_mark + truncated_option + "\n"))
            }
            else: {
                print_blank(cursor_len)
                eprintf(check_mark + truncated_option + "\n")
            }
        }
    }
    let remaining_slots = display_count - len(page_options)
    if remaining_slots > 0 { // Amber bug guard
        for _ in 0..remaining_slots {
            eprintf("\x1b[K\n")
        }
    }
}

fun render_page_indicator(page: Int, total_pages: Int): Null {
    if total_pages > 1 {
        eprintf("\x1b[9999D\x1b[K")
        eprintf_colored("Page {page + 1}/{total_pages}", 90)
        eprintf("\x1b[9999D")
    }
}

/// Prompts the user to choose a single option from a list.
///
/// ### Parameters
/// - `options`: The list of options to choose from.
/// - `cursor`: The cursor text to indicate the selected option.
/// - `header`: An optional header message to display above the options. (ANSI supported)
/// - `page_size`: The number of options to display per page.
pub fun xyl_choose(
    options: [Text],
    cursor: Text = "> ",
    header: Text = "\x1b[1mChoose:\x1b[0m",
    page_size: Int = 10,
): Text {
    if len(options) == 0 {
        eprintf_colored("ERROR: No options provided.\n", 31)
        exit(1)
    }

    stty_lock()
    hide_cursor()

    let term_width = term_width()
    let term_height = term_height()
    let max_page_size = term_height - (header == "" then 2 else 3)
    if page_size > max_page_size {
        page_size = max_page_size
    }

    if header != "" {
        eprintf(cutoff_text(header, term_width) + "\n")
    }

    let total_pages = math_floor((len(options) + page_size - 1) / page_size)
    let current_page = 0
    let selected = 0

    let display_count = page_size
    if len(options) < page_size {
        display_count = len(options)
    }

    new_line(display_count)
    eprintf("\x1b[9999D")
    if total_pages > 1 {
        eprintf_colored("Page {current_page + 1}/{total_pages}", 90)
    }
    new_line(1)

    // "↑↓ select • enter confirm" = 9 + 3 + 13 = 25
    // "↑↓ select • ←→ page • enter confirm" = 9 + 3 + 8 + 3 + 13 = 36
    if total_pages > 1 {
        render_tooltip(["↑↓", "select", "←→", "page", "enter", "confirm"], 36, term_width)
    } else {
        render_tooltip(["↑↓", "select", "enter", "confirm"], 25, term_width)
    }
    go_up(display_count + 1)
    eprintf("\x1b[9999D")

    let page_options = get_page_options(options, current_page, page_size)
    render_choose_page(page_options, selected, cursor, display_count, term_width)

    loop {
        let key = get_key()

        let prev_selected = selected
        let prev_page = current_page
        let up_paged = false

        if {
            key == "UP" or key == "k" {
                if {
                    selected == 0 and total_pages > 1 {
                        if current_page > 0 {
                            current_page -= 1
                        } else {
                            current_page = total_pages - 1
                        }
                        up_paged = true
                    }
                    selected == 0 {
                        selected = len(page_options) - 1
                    }
                    else {
                        selected = selected - 1
                    }
                }
            }
            key == "DOWN" or key == "j" {
                if selected == len(page_options) - 1 {
                    if current_page < total_pages - 1 {
                        current_page += 1
                        selected = 0
                    } else {
                        current_page = 0
                        selected = 0
                    }
                } else {
                    selected = selected + 1
                }
            }
            key == "LEFT" or key == "h" {
                if current_page > 0 {
                    current_page -= 1
                    selected = 0
                } else {
                    selected = 0
                }
            }
            key == "RIGHT" or key == "l" {
                if current_page < total_pages - 1 {
                    current_page += 1
                    selected = 0
                } else {
                    selected = len(page_options) - 1
                }
            }
            key == "INPUT" {
                break
            }
            else: continue
        }

        let max_option_width = term_width - len(cursor) - 1
        if {
            prev_page != current_page {
                page_options = get_page_options(options, current_page, page_size)
                if up_paged {
                    selected = len(page_options) - 1
                }
                go_up(1)
                remove_line(display_count - 1)
                remove_current_line()
                eprintf("\x1b[9999D")
                render_choose_page(page_options, selected, cursor, display_count, term_width)
                render_page_indicator(current_page, total_pages)
            }
            prev_selected != selected {
                go_up(display_count - prev_selected)
                eprintf("\x1b[K")
                print_blank(len(cursor))
                eprintf(cutoff_text(page_options[prev_selected], max_option_width))

                let diff = selected - prev_selected
                go_up_or_down(diff)
                eprintf("\x1b[9999D")
                eprintf("\x1b[K")
                eprintf(colored_secondary(cursor + cutoff_text(page_options[selected], max_option_width)))

                go_down(display_count - selected)
                eprintf("\x1b[9999D")
            }
        }
    }

    let total_lines = display_count + 2
    if header != "" {
        total_lines += 1
    }

    go_down(1)
    remove_line(total_lines - 1)
    remove_current_line()

    stty_unlock()
    show_cursor()
    let global_selected = current_page * page_size + selected
    return options[global_selected]
}

fun count_checked(checked: [Bool]): Int {
    let count = 0
    for c in checked {
        if c {
            count += 1
        }
    }
    return count
}

/// Prompts the user to choose multiple options from a list.
///
//// ### Parameters
/// - `options`: The list of options to choose from.
/// - `cursor`: The cursor text to indicate the selected option.
/// - `header`: An optional header message to display above the options. (ANSI supported)
/// - `limit`: The maximum number of options the user can select. Use -1 for no limit.
/// - `page_size`: The number of options to display per page.
pub fun xyl_multi_choose(
    options: [Text],
    cursor: Text = "> ",
    header: Text = "Choose:",
    limit: Int = -1,
    page_size: Int = 10,
): [Text] {
    if len(options) == 0 {
        eprintf_colored("ERROR: No options provided.\n", 31)
        return [Text]
    }

    stty_lock()
    hide_cursor()

    let term_width = term_width()
    let term_height = term_height()
    let max_page_size = term_height - (header == "" then 2 else 3)
    if page_size > max_page_size {
        page_size = max_page_size
    }

    if header != "" {
        eprintf(cutoff_text(header, term_width) + "\n")
    }

    let total_pages = math_floor((len(options) + page_size - 1) / page_size)
    let current_page = 0
    let selected = 0

    let display_count = page_size
    if len(options) < page_size {
        display_count = len(options)
    }

    new_line(display_count)
    eprintf("\x1b[9999D")
    if total_pages > 1 {
        eprintf_colored("Page {current_page + 1}/{total_pages}", 90)
    }
    new_line(1)

    // "↑↓ select • x toggle • enter confirm" = 9 + 3 + 8 + 3 + 13 = 36
    // "↑↓ select • x toggle • a all • enter confirm" = 36 + 5 + 3 = 44
    // "↑↓ select • x toggle • ←→ page • enter confirm" = 36 + 8 + 3 = 47
    // "↑↓ select • x toggle • a all • ←→ page • enter confirm" = 36 + 5 + 3 + 8 + 3 = 55
    if {
        total_pages > 1 and limit < 0: render_tooltip(["↑↓", "select", "x", "toggle", "a", "all", "←→", "page", "enter", "confirm"], 55, term_width)
        total_pages > 1: render_tooltip(["↑↓", "select", "x", "toggle", "←→", "page", "enter", "confirm"], 47, term_width)
        limit < 0: render_tooltip(["↑↓", "select", "x", "toggle", "a", "all", "enter", "confirm"], 44, term_width)
        else: render_tooltip(["↑↓", "select", "x", "toggle", "enter", "confirm"], 36, term_width)
    }
    go_up(display_count + 1)
    eprintf("\x1b[9999D")

    let checked = [Bool]
    for _ in 0..len(options) {
        checked += [false]
    }

    let page_options = get_page_options(options, current_page, page_size)
    let page_start = get_page_start(current_page, page_size)
    render_multi_choose_page(page_options, checked, page_start, selected, cursor, display_count, term_width)

    loop {
        let key = get_key()

        let prev_selected = selected
        let prev_page = current_page
        let global_selected = page_start + selected
        let up_paged = false

        if {
            key == "UP" or key == "k" {
                if {
                    selected == 0 and total_pages > 1 {
                        if current_page > 0 {
                            current_page -= 1
                        } else {
                            current_page = total_pages - 1
                        }
                        up_paged = true
                    }
                    selected == 0 {
                        selected = len(page_options) - 1
                    }
                    else {
                        selected = selected - 1
                    }
                }
            }
            key == "DOWN" or key == "j" {
                if selected == len(page_options) - 1 {
                    if current_page < total_pages - 1 {
                        current_page += 1
                        selected = 0
                    } else {
                        current_page = 0
                        selected = 0
                    }
                } else {
                    selected = selected + 1
                }
            }
            key == "LEFT" or key == "h" {
                if current_page > 0 {
                    current_page -= 1
                    selected = 0
                } else {
                    selected = 0
                }
            }
            key == "RIGHT" or key == "l" {
                if current_page < total_pages - 1 {
                    current_page += 1
                    selected = 0
                } else {
                    selected = len(page_options) - 1
                }
            }
            key == "x" or key == "X" {
                if {
                    checked[global_selected] {
                        checked[global_selected] = false
                    }
                    limit < 0 or count_checked(checked) < limit {
                        checked[global_selected] = true
                    }
                    else: continue
                }
                let max_option_width = term_width - len(cursor) - 2 - 1 // 2 for check mark
                go_up(display_count - selected)
                eprintf("\x1b[9999D")
                eprintf("\x1b[K")
                let check_mark = checked[global_selected] then "✓ " else "• "
                eprintf(colored_secondary(cursor + check_mark + cutoff_text(page_options[selected], max_option_width)))
                go_down(display_count - selected)
                eprintf("\x1b[9999D")
                continue
            }
            (key == "a" or key == "A") and limit < 0 {
                let all_checked = count_checked(checked) == len(options)
                for i in 0..len(checked) {
                    checked[i] = not all_checked
                }
                go_up(display_count)
                eprintf("\x1b[9999D")
                render_multi_choose_page(page_options, checked, page_start, selected, cursor, display_count, term_width)
                continue
            }
            key == "INPUT" {
                break
            }
            else: continue
        }

        let max_option_width = term_width - len(cursor) - 2 - 1 // 2 for check mark
        if {
            prev_page != current_page {
                page_options = get_page_options(options, current_page, page_size)
                page_start = get_page_start(current_page, page_size)
                if up_paged {
                    selected = len(page_options) - 1
                }
                go_up(1)
                remove_line(display_count - 1)
                remove_current_line()
                eprintf("\x1b[9999D")
                render_multi_choose_page(page_options, checked, page_start, selected, cursor, display_count, term_width)
                render_page_indicator(current_page, total_pages)
            }
            prev_selected != selected {
                let prev_global = page_start + prev_selected
                go_up(display_count - prev_selected)
                eprintf("\x1b[K")
                print_blank(len(cursor))
                if checked[prev_global] {
                    eprintf(colored_secondary("✓ " + cutoff_text(page_options[prev_selected], max_option_width)))
                } else {
                    eprintf("• " + cutoff_text(page_options[prev_selected], max_option_width))
                }

                let diff = selected - prev_selected
                go_up_or_down(diff)
                eprintf("\x1b[9999D")
                eprintf("\x1b[K")
                let new_global = page_start + selected
                let check_mark = checked[new_global] then "✓ " else "• "
                eprintf(colored_secondary(cursor + check_mark + cutoff_text(page_options[selected], max_option_width)))

                go_down(display_count - selected)
                eprintf("\x1b[9999D")
            }
        }
    }

    let total_lines = display_count + 2
    if header != "" {
        total_lines += 1
    }

    go_down(1)
    remove_line(total_lines - 1)
    remove_current_line()

    let result = [Text]
    for i in 0..len(options) {
        if checked[i] {
            result += [options[i]]
        }
    }

    stty_unlock()
    show_cursor()

    return result
}
