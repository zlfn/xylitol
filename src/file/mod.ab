import * from "std/env"
import * from "std/text"
import * from "../utils.ab"
import { xyl_choose } from "../choose/mod.ab"

/// Format a single entry for display
/// Directories are colored with accent color and have trailing /
fun format_entry_display(entry: [Text]): Text {
    let name = entry[0]
    let file_type = entry[1]

    if file_type == "d" {
        return name + colored_primary("/")
    }
    if file_type == "l" {
        return name + colored_accent(" > ") + colored_primary(entry[2])
    }
    return name
}

/// File browser that lets user navigate and select a file.
///
/// ### Parameters
/// - `start_path`: Starting directory path (default: current directory).
/// - `cursor`: The cursor text to indicate the selected option.
/// - `show_hidden`: Whether to show hidden files (starting with .).
/// - `page_size`: The number of entries to display per page.
pub fun xyl_file(
    start_path: Text = "",
    cursor: Text = "> ",
    show_hidden: Bool = false,
    page_size: Int = 10,
): Text {
    stty_lock()

    let term_width = term_width()
    let max_entry_width = term_width - len(cursor) - 1

    // Initialize current path
    let current_path = start_path
    if current_path == "" {
        current_path = get_cwd()
    }
    current_path = normalize_path(current_path)

    loop {
        eprintf(colored_primary("Loading files..."))

        // Get directory entries
        let raw_entries = get_directory_entries(current_path)

        // Build options list and parallel entries list
        let options = [Text]
        let entries = [Text]

        // Add parent directory entry (..)
        if current_path != "/" {
            options += [".."]
            entries += ["..\td"]
        }

        for raw_entry in raw_entries {
            let entry = parse_entry(raw_entry)
            let name = entry[0]
            // Skip hidden files if not showing them
            let first_char = trust $ echo "{name}" | cut -c1 $
            if not show_hidden and first_char == "." {
                continue
            }
            options += [format_entry_display(entry)]
            entries += [raw_entry]
        }

        if len(entries) == 0 {
            eprintf_colored("ERROR: Directory is empty or inaccessible.\n", 31)
            stty_unlock()
            return ""
        }

        // Use xyl_choose with current path as header
        let header = colored_primary(current_path)

        remove_current_line()
        let selected_option = xyl_choose(options, cursor, header, page_size)

        // Find selected entry index
        let selected_idx = -1
        for i in 0..len(options) {
            if options[i] == selected_option {
                selected_idx = i
                break
            }
        }

        if selected_idx < 0 {
            return ""
        }

        let entry = parse_entry(entries[selected_idx])
        let name = entry[0]
        let file_type = entry[1]

        if {
            name == ".." {
                current_path = get_parent_dir(current_path)
            }
            file_type == "d" {
                current_path = path_join(current_path, name)
                current_path = normalize_path(current_path)
            }
            file_type == "l" {
                // For symlinks, check if they point to a directory
                if starts_with(entry[2], "/") {
                    current_path = entry[2]
                    current_path = normalize_path(current_path)
                } else {
                    stty_unlock()
                    return path_join(current_path, entry[2])
                }
            }
            else: {
                stty_unlock()
                return path_join(current_path, name)
            }
        }
    }

    stty_unlock()
    return ""
}
