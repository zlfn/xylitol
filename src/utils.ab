import { printf } from "std/env"
import * from "std/text"
pub import * from "utils/fs.ab" 
pub import * from "utils/perl.ab"
pub import * from "utils/term.ab"
pub import * from "utils/truecolor.ab"

///// IO Functions /////

/// Reads a single character from terminal.
pub fun get_char(): Text {
    let char = trust $ read -n 1 key < /dev/tty; printf "%s" "\$key" $
    return char
}

/// Reads a key from terminal, including special keys (arrows, backspace, etc.)
pub fun get_key(): Text {
    let var = trust $ read -rsn1 k < /dev/tty; if [[ "\$k" == \$'\e' ]]; then read -rsn2 r < /dev/tty; k+=\$r; fi; printf '%q' "\$k" $
    if {
        var == "$'\E[A'": return "UP"
        var == "$'\E[B'": return "DOWN"
        var == "$'\E[C'": return "RIGHT"
        var == "$'\E[D'": return "LEFT"
        var == "$'\177'": return "BACKSPACE"
        var == "''": return "INPUT"
        else: return var
    }
}

pub fun printf_colored(message: Text, color: Int): Null {
    /// Prints a text with a specified color.
    printf("\x1b[{color as Text}m%s\x1b[0m", [message])
}

pub fun eprintf(format: Text, args: [Text] = [""]): Null {
    trust $ {nameof args}=("{format}" "\$\{{nameof args}[@]}") $
    trust $ printf "\$\{{nameof args}[@]}" >&2 $
}

pub fun eprintf_colored(message: Text, color: Int): Null {
    /// Prints an error message with a specified color.
    eprintf("\x1b[{color as Text}m%s\x1b[0m", [message])
}

pub fun colored(message: Text, color: Int): Text {
    /// Returns a text wrapped in color codes.
    return "\x1b[{color as Text}m" + message + "\x1b[0m"
}

/// remove `cnt` characters from the terminal.
pub fun remove(cnt: Int): Null {
   trust $ printf '%0.s\b \b' \$(seq 1 {cnt}) >&2 $
}

/// remove `cnt` lines from the terminal (starting from current line, going up).
pub fun remove_line(cnt: Int): Null {
    trust $ printf '\x1b[2K\x1b[1A%.0s' \$(seq {cnt as Text}) >&2 $
    eprintf("\x1b[9999D")
}

/// remove the current line from the terminal.
pub fun remove_current_line(): Null {
    eprintf("\x1b[2K\x1b[9999D")
}

/// Prints blank spaces.
/// ### Parameters
/// - `cnt`: Number of spaces to print.
pub fun print_blank(cnt: Int): Null {
    trust $ printf '%*s' "{cnt as Text}" ' ' >&2 $
}

pub fun new_line(cnt: Int): Null {
    for i in 0..cnt {
        eprintf("\n")
    }
}

/// move the cursor up `cnt` lines.
pub fun go_up(cnt: Int): Null {
    eprintf("\x1b[{cnt as Text}A")
}

/// move the cursor down `cnt` lines.
pub fun go_down(cnt: Int): Null {
    eprintf("\x1b[{cnt as Text}B")
}

// move the cursor up or down `cnt` lines.
pub fun go_up_or_down(cnt: Int): Null {
    if cnt > 0 {
        go_down(cnt)
    } else {
        go_up(-cnt)
    }
}

pub fun hide_cursor(): Null {
    eprintf("\x1b[?25l")
}

pub fun show_cursor(): Null {
    eprintf("\x1b[?25h")
}

//// Text Utilities /////

/// Checks if the text contains ANSI escape sequences.
/// Returns true if the text contains "\x1b[".
pub fun has_ansi_escape(text: Text): Bool {
    // Check for ESC character (0x1B = 27) or literal \x1b[
    let has_escape = trust $ [[ "{text}" == *\$'\x1b'* || "{text}" == *'\x1b['* ]] && echo "1" || echo "0" $
    return has_escape == "1"
}

/// Convert real ESC characters (0x1b) to literal \x1b string.
/// This normalizes ANSI escape sequences for internal processing.
pub fun escape_ansi(text: Text): Text {
    return trust $ printf '%s' "{text}" | sed \$'s/\x1b/\\\\x1b/g' $
}

/// Remove ANSI escape sequences from text.
pub fun strip_ansi(text: Text): Text {
    return trust $ printf "%s" "{text}" | sed \$'s/\x1b\\[[0-9;]*m//g' | sed 's/\\\\x1b\\[[0-9;]*m//g' $
}

/// Check if the text is all ASCII characters (code points 32-126).
pub fun is_all_ascii(text: Text): Bool {
    let result = trust $ printf "%s" "{text}" | LC_ALL=C grep -q '^[ -~]*\$' && echo 0 || echo 1 $
    return result == "0"
}

/// Get visible length of ANSI-colored text (excluding escape sequences).
///
/// ### Parameters
/// - `text`: Text that may contain ANSI escape sequences.
pub fun get_visible_len(text: Text): Int {
    let stripped = strip_ansi(text)
    // Check if text is all ASCII
    if not is_all_ascii(stripped) {
        // Try using perl
        return perl_get_cjk_width(stripped) failed {
            return len(stripped)
        }
    } else {
        return len(stripped)
    }
}

/// Truncate text to fit within max_width without adding any suffix.
/// Simply cuts the text to fit within the specified width.
pub fun truncate_text(text: Text, max_width: Int): Text {
    let visible_len = get_visible_len(text)
    if visible_len <= max_width {
        return text
    }
    if not is_all_ascii(text) {
        return perl_truncate_cjk(text, max_width) failed {
            trust $ printf "%s" "{text}" | cut -c1-{max_width} $
        }
    }
    return trust $ printf "%s" "{text}" | cut -c1-{max_width} $
}

/// Truncate ANSI-colored text to fit within max_width.
/// Preserves ANSI escape sequences while truncating visible content.
/// ANSI sequences are expected in literal \x1b format.
pub fun truncate_ansi(text: Text, max_width: Int): Text {
    if not has_ansi_escape(text) {
        return truncate_text(text, max_width)
    }

    // Check if text starts with \x1b[
    let starts_with_ansi = trust $ [[ "{text}" == '\\x1b['* ]] && echo "1" || echo "0" $

    // Replace \x1b[ with newline, then split
    let replaced = trust $ t="{text}"; printf '%s' "\$\{t//\\\\x1b[/
}" $
    let parts = split(replaced, "\n")
    let result = ""
    let remaining_width = max_width

    for idx in 0..len(parts) {
        let part = parts[idx]

        // If text starts with ANSI, all parts are "ANSIparams m text" format
        // If not, first part is pure text
        if idx == 0 and starts_with_ansi == "0" {
            // First part is pure text (before any ANSI)
            if part != "" and remaining_width > 0 {
                let truncated = truncate_text(part, remaining_width)
                result += truncated
                remaining_width -= get_visible_len(truncated)
            }
        } else {
            // Part is "ANSIparams m text" format - find first 'm'
            let m_idx = trust $ __p="{part}"; for ((i=0; i<\$\{#__p}; i++)); do [[ "\$\{__p:\$i:1}" == "m" ]] && echo \$i && break; done $
            if m_idx != "" {
                // Reconstruct ANSI sequence
                let ansi_params = trust $ __p="{part}"; printf "%s" "\$\{__p:0:{m_idx}}" $
                result += "\\x1b[" + ansi_params + "m"

                // Rest is text content
                let m_idx_num = trust parse_int(m_idx)
                let text_start = m_idx_num + 1
                let text_part = trust $ __p="{part}"; printf "%s" "\$\{__p:{text_start}}" $
                if text_part != "" and remaining_width > 0 {
                    let truncated = truncate_text(text_part, remaining_width)
                    result += truncated
                    remaining_width -= get_visible_len(truncated)
                }
            } else {
                // No 'm' found, treat as text
                if part != "" and remaining_width > 0 {
                    let truncated = truncate_text(part, remaining_width)
                    result += truncated
                    remaining_width -= get_visible_len(truncated)
                }
            }
        }
    }

    return result
}

/// Truncate text to fit within max_width, adding "..." if truncated.
/// The max_width includes the "..." suffix.
pub fun cutoff_text(text: Text, max_width: Int): Text {
    let visible_len = get_visible_len(text)
    if visible_len <= max_width {
        return text
    }
    return truncate_ansi(text, max_width - 3) + "..."
}

///// Application Utilities /////

/// Render a tooltip line with key-action pairs.
/// Format: "key action • key action • ..."
/// Truncates if exceeds term_width.
///
/// ### Parameters
/// - `items`: Flat array of key, action pairs. e.g. ["↑↓", "select", "enter", "confirm"]
/// - `total_len`: Pre-calculated total visible length of the tooltip.
/// - `term_width`: Terminal width to truncate output.
pub fun render_tooltip(items: [Text], total_len: Int, term_width: Int): Null {
    let separator = " • "
    let separator_len = 3

    // Fast path: no truncation needed
    if total_len <= term_width {
        let iter = 0
        loop {
            if {
                iter >= len(items): break
                iter > 0: eprintf_colored(separator, 90)
            }
            eprintf(items[iter] + " " + colored(items[iter + 1], 2))
            iter += 2
        }
    } else {
        // Slow path: truncate
        let current_len = 0
        let first = true
        let iter = 0
        loop {
            if iter >= len(items) {
                break
            }
            let key = items[iter]
            let action = items[iter + 1]
            let part_len = len(key) + 1 + len(action)

            let needed = part_len
            if not first {
                needed += separator_len
            }

            if current_len + needed > term_width {
                break
            }

            if not first {
                eprintf_colored(separator, 90)
            }
            eprintf(key + " " + colored(action, 2))
            current_len += needed
            first = false
            iter += 2
        }
    }
}

